/**
 * Optimized Lazy Image Component
 * Implements intersection observer-based lazy loading with performance optimizations
 */

import React, { useState, useRef, useEffect, useCallback } from 'react';
import { useIntersectionObserver } from '../hooks/useIntersectionObserver';

export interface LazyImageProps extends Omit<React.ImgHTMLAttributes<HTMLImageElement>, 'src'> {
  src: string;
  alt: string;
  placeholderSrc?: string;
  blurDataURL?: string;
  threshold?: number;
  rootMargin?: string;
  sizes?: string;
  priority?: boolean;
  objectFit?: 'contain' | 'cover' | 'fill' | 'none' | 'scale-down';
  onLoad?: () => void;
  onError?: () => void;
}

export const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  placeholderSrc = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PC9zdmc+',
  blurDataURL,
  threshold = 0.1,
  rootMargin = '50px',
  sizes,
  priority = false,
  objectFit = 'cover',
  onLoad,
  onError,
  className = '',
  style,
  ...props
}) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isError, setIsError] = useState(false);
  const [imageSrc, setImageSrc] = useState<string>(placeholderSrc);
  const imgRef = useRef<HTMLImageElement>(null);
  const imageRef = useRef<HTMLImageElement | null>(null);

  // Use intersection observer for lazy loading
  const [isIntersecting] = useIntersectionObserver(imgRef, {
    threshold,
    rootMargin,
    triggerOnce: true,
    skip: priority // Skip observation if priority is true
  });

  // Load image when in viewport or if priority is set
  const shouldLoad = priority || isIntersecting;

  const handleImageLoad = useCallback(() => {
    setIsLoaded(true);
    setIsError(false);
    onLoad?.();
  }, [onLoad]);

  const handleImageError = useCallback(() => {
    setIsError(true);
    setIsLoaded(false);
    onError?.();
  }, [onError]);

  // Create and load the actual image
  useEffect(() => {
    if (!shouldLoad) return;

    const img = new Image();
    imageRef.current = img;

    img.onload = () => {
      setImageSrc(src);
      handleImageLoad();
    };

    img.onerror = handleImageError;

    // Set sizes attribute for responsive images
    if (sizes) {
      img.sizes = sizes;
    }

    img.src = src;

    return () => {
      if (imageRef.current) {
        imageRef.current.onload = null;
        imageRef.current.onerror = null;
      }
    };
  }, [shouldLoad, src, sizes, handleImageLoad, handleImageError]);

  // Generate responsive srcSet if sizes are provided
  const generateSrcSet = useCallback((baseSrc: string) => {
    if (!sizes) return undefined;
    
    // This would typically be generated by your image optimization service
    // For now, we'll return the base src
    return baseSrc;
  }, [sizes]);

  const containerStyle: React.CSSProperties = {
    ...style,
    position: 'relative',
    overflow: 'hidden'
  };

  const imageStyle: React.CSSProperties = {
    objectFit,
    transition: 'opacity 0.3s ease-in-out',
    opacity: isLoaded ? 1 : 0,
    width: '100%',
    height: '100%'
  };

  const placeholderStyle: React.CSSProperties = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    objectFit,
    opacity: isLoaded ? 0 : 1,
    transition: 'opacity 0.3s ease-in-out',
    filter: blurDataURL ? 'blur(10px)' : undefined
  };

  return (
    <div 
      className={`lazy-image-container ${className}`}
      style={containerStyle}
    >
      {/* Placeholder image */}
      <img
        src={blurDataURL || placeholderSrc}
        alt=""
        style={placeholderStyle}
        aria-hidden="true"
      />
      
      {/* Main image */}
      <img
        {...props}
        ref={imgRef}
        src={imageSrc}
        alt={alt}
        style={imageStyle}
        srcSet={generateSrcSet(imageSrc)}
        sizes={sizes}
        loading={priority ? 'eager' : 'lazy'}
        decoding="async"
      />
      
      {/* Error state */}
      {isError && (
        <div 
          className="absolute inset-0 flex items-center justify-center bg-gray-100 text-gray-500"
          role="img"
          aria-label="Image failed to load"
        >
          <svg 
            className="w-12 h-12" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" 
            />
          </svg>
        </div>
      )}
      
      {/* Loading indicator */}
      {shouldLoad && !isLoaded && !isError && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-50">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
        </div>
      )}
    </div>
  );
};

// Hook for intersection observer
function useIntersectionObserver(
  ref: React.RefObject<Element>,
  options: {
    threshold?: number;
    rootMargin?: string;
    triggerOnce?: boolean;
    skip?: boolean;
  } = {}
): [boolean] {
  const [isIntersecting, setIsIntersecting] = useState(false);
  const [hasTriggered, setHasTriggered] = useState(false);

  useEffect(() => {
    if (options.skip || (options.triggerOnce && hasTriggered)) {
      return;
    }

    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        const isElementIntersecting = entry.isIntersecting;
        setIsIntersecting(isElementIntersecting);
        
        if (isElementIntersecting && options.triggerOnce) {
          setHasTriggered(true);
        }
      },
      {
        threshold: options.threshold || 0,
        rootMargin: options.rootMargin || '0px'
      }
    );

    observer.observe(element);

    return () => {
      observer.disconnect();
    };
  }, [ref, options.threshold, options.rootMargin, options.triggerOnce, options.skip, hasTriggered]);

  // If skip is true, return true immediately
  if (options.skip) {
    return [true];
  }

  return [isIntersecting || hasTriggered];
}

// Optimized image gallery component
interface ImageGalleryProps {
  images: Array<{
    src: string;
    alt: string;
    thumbnail?: string;
    caption?: string;
  }>;
  className?: string;
  onImageClick?: (index: number) => void;
}

export const OptimizedImageGallery: React.FC<ImageGalleryProps> = ({
  images,
  className = '',
  onImageClick
}) => {
  return (
    <div className={`grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 ${className}`}>
      {images.map((image, index) => (
        <div
          key={index}
          className="aspect-square cursor-pointer hover:opacity-90 transition-opacity"
          onClick={() => onImageClick?.(index)}
        >
          <LazyImage
            src={image.thumbnail || image.src}
            alt={image.alt}
            className="w-full h-full rounded-lg"
            objectFit="cover"
            sizes="(max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
          />
          {image.caption && (
            <p className="mt-2 text-sm text-gray-600 truncate">
              {image.caption}
            </p>
          )}
        </div>
      ))}
    </div>
  );
};